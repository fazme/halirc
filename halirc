#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
TODO
Harmony: LG alles!!!!!! separate Codes vom Receiver12V anlernen
Harmony: Denon Lautstaerke und Mute dito
"""
import datetime, sys, os, socket
import logging, logging.handlers
import serial, re, time
from optparse import OptionParser
from telnetlib import Telnet


LOGGER = None
OPTIONS = None

class Device(object):
    """if we ever support other than SerialDevices, we should
    move some methods here from SerialDevice"""
    def __init__(self, name):
        self.deviceName = name
        self.event = None # the event we are currently reacting on
        self.lastUsed = None
        self.lastOpenFailTime = None
        self.closeAfterUnusedSeconds = 5

    def setEvent(self, event):
        """event is the next event to be processed or None if there
        was no event while timeout"""
        self.event = event
        if not event and self.lastUsed:
            if elapsedSince(self.lastUsed) > self.closeAfterUnusedSeconds:
                self.close()

    def open(self):
        """open device. Please override. Return False if open fails"""
        if self.lastOpenFailTime and elapsedSince(self.lastOpenFailTime) < 10:
            # if the previous open failed, wait for a moment until retry
            return False
        self.lastOpenFailTime = None # after timeout, forget cached error
        if 's' in OPTIONS.debug or 'r' in OPTIONS.debug:
            LOGGER.debug('opening %s' % type(self).__name__)
        self.lastUsed = datetime.datetime.now()
        return True

    def close(self, openFailed=False):
        """reset closing timer. Please override."""
        if openFailed:
            self.lastOpenFailTime = datetime.datetime.now()
        else:
            self.lastOpenFailTime = None
        self.lastUsed = None
        if 's' in OPTIONS.debug or 'r' in OPTIONS.debug:
            LOGGER.debug('closing %s' % type(self).__name__)

class SerialDevice(Device):
    """for RS232 connections"""
    # pylint: disable=R0913
    # too many arguments
    def __init__(self, name, baud=9600, bits=8, parity=serial.PARITY_NONE,
              stop=serial.STOPBITS_ONE, timeout=0.01, xonxoff=0, rtscts=0):
        Device.__init__(self, name)
        self.baud = baud
        self.bits = bits
        self.parity = parity
        self.stop = stop
        self.timeout = timeout
        self.xonxoff = xonxoff
        self.rtscts = rtscts
        self.serio = None
        # the usb/serial needs 1/4 second for open!
        self.closeAfterUnusedSeconds = 10

    def init(self):
        """initialize device for normal usage"""
        pass

    def isPoweredOn(self):
        """is the device powered on?"""
        pass

    # pylint: disable=R0201
    # this could be a function but not the descendants
    def delay(self, dummyCommand=None, dummyParameters=None):
        """how long should we wait for answer from device?"""
        return 10

    def readline(self, eol):
        """only call this when we know the device is
        ready for sending"""
        if not self.open():
            return ''
        result = ''
        waited = 0
        while True:
            char = self.serio.read(1)
            waited = waited + self.serio.timeout
            if char == '':
                if waited >= self.delay():
                    break
                else:
                    continue
            if char == eol:
                break
            result += char
        if result and 'r' in OPTIONS.debug:
            LOGGER.debug('from %s: %s' % (type(self).__name__, result))
        return result

    def communicate(self, data, getAnswer=False, eol='\r'):
        """send data to device, set lastUsed, optionally get answer from device"""
        if not self.open():
            return ''
        if 's' in OPTIONS.debug:
            LOGGER.debug('sending to %s: %s' % (type(self).__name__, data))
        self.serio.write(data)
        self.lastUsed = datetime.datetime.now()
        if getAnswer:
            result = self.readline(eol)
        else:
            result = None
        return result

    def open(self):
        """if the device is not connected, do so"""
        if not self.serio:
            if not Device.open(self):
                return False
            try:
                self.serio = serial.Serial(self.deviceName, baudrate=self.baud,
                  bytesize=self.bits, parity=self.parity,
                  stopbits=self.stop, timeout=self.timeout,
                  xonxoff=self.xonxoff, rtscts=self.rtscts)
            except Exception as exception: # pylint: disable=W0703
                LOGGER.error('cannot open %s: %s' % (type(self).__name__, exception))
                return False
        return True

    def close(self, openFailed=False):
        """only close when unused for some time, see caller"""
        if self.serio:
            self.serio.close()
            self.serio = None
        Device.close(self, openFailed)

class VDRServer(Device):
    """talks to VDR"""
    def __init__(self, name='VDR', host='localhost', port=6419):
        Device.__init__(self, name)
        self.host = host
        self.port = port
        self.telnet = None

    def open(self):
        """open connection if not open"""
        if not self.telnet:
            if not Device.open(self):
                return False
            self.telnet = Telnet()
            self.telnet.open(self.host, self.port, timeout=10)
            greeting = self.telnet.read_until('\n', timeout=2)[:-1]
            if not greeting:
                greeting = 'VDR server is probably in use'
            if greeting.split(' ')[0] != '220':
                LOGGER.error('VDR server is not ready: %s' % greeting)
                self.close(openFailed=True)
                return False
        return True

    def close(self, openFailed=False):
        """close connection if open"""
        if self.telnet:
            self.telnet.write('quit\n')
            self.telnet.close()
            self.telnet = None
        Device.close(self, openFailed)

    def send(self, cmd):
        """send data to VDR"""
        if not self.open():
            return ''
        if cmd[-1] != '\n':
            cmd = cmd + '\n'
        if 's' in OPTIONS.debug:
            LOGGER.debug('sending to %s: %s' % (type(self).__name__, cmd[:-1]))
        self.telnet.write(cmd)
        result = self.telnet.read_until('\n')[:-2] # line end is CRLF
        if result.split(' ')[0] not in ['250', '354', '550']:
            LOGGER.error('from %s: %s' % (type(self).__name__, result))
        else:
            if 'r' in OPTIONS.debug:
                LOGGER.debug('from %s: %s' % (type(self).__name__, result))
        return result

    def getChannel(self,):
        """returns current channel number and name"""
        answer = self.send('chan').split(' ')
        if answer[0] != '250':
            return 'nochannelfound'
        return answer[1], ' '.join(answer[2:])

    def gotoChannel(self, channel):
        """go to a channel if not yet there.
        Channel number and name are both accepted."""
        if channel not in self.getChannel():
            self.send('chan %s' % channel)

    def switchVt(self, which):
        """activate desktop or video vt"""
        if which == 'desktop':
#            lg.init()
            os.system('chvt 7')
            self.send('hitk stop') # stop playing
        elif which == 'video':
#            lg.init()
            os.system('chvt `cat /video0/vdrconsole`')
            # reselect current channel, otherwise we have no picture with vdpau/X11
            self.send('chan %s' % self.getChannel()[0])
        else:
            raise Exception('VDR.switchVt only accepts desktop and video')

class Denon(SerialDevice):
    """support the more important things the denon interface
    lets us do. Denon has published AVR-3805SerialProtocolv4-0.PDF
    which mostly also works for my AVR-2805 and maybe others.

    The Denon has a problem with commands in fast succession: after
    some commands, some others are ignored if they are sent too soon.
    Between SI..SI (Select Input) a small time is needed. But for
    MV (Master Volume) after SI, we must wait for about 2 seconds,
    or the MV command will silently be ignored. There might be
    more sophisticated ways to handle this like waiting for a
    response with SI - but that would not be simpler. If several
    SI are sent in quick sequence, Denon will send a response for
    only one of them even if it executes them all
    self.delays defines waiting times for between command A and B

    An alternative solution is to repeatedly send the command until
    the Denon sends the wanted answer. Like def standby(). But some
    Denon commands never send answers at all...

    """

    def __init__(self, device='/dev/denon'):
        SerialDevice.__init__(self, device)
        self.mutedVolume = None
        self.current = {}
        self.lastSentCmd = None
        self.lastSentTime = None
        # virtually never close because the Denon sends events
        # by its own if it is operated by other means (IR, front knobs)
        self.closeAfterUnusedSeconds = 10000000
        self.delays = {'SIMV': 2.0, 'xW..': 2.0}

    def setEvent(self, event):
        """event is the next event to be processed or None if there
        was no event while timeout"""
        SerialDevice.setEvent(self, event)
        if not event:
            self.getResponses()

    def init(self):
        """initialize the Denon to sane values"""
        if not self.isPoweredOn():
            self.send('PWON')
            while self.current['PW'] != 'ON':
                self.getResponses()
                self.send('PWON')
                time.sleep(0.5)

    def standby(self):
        """set the device to standby"""
        if self.isPoweredOn():
            while self.current['PW'] == 'ON':
                self.getResponses()
                self.send('PWSTANDBY')
                time.sleep(0.5)
        self.mutedVolume = None

    def delay(self, dummyCommand=None, dummyParameters=None):
        return 0.02

    # pylint: disable=R0201
    def parse(self, data):
        """split data into key, index and value.
        index is None if a request has only one return value"""
        key, subcmd, index, maxIndex, value = data[:2], None, None, None, data[2:]
        if value != '?':
            if key == 'CV':
                subcmd, value = value.split(' ')
                subcommands = ['FL', 'FR', 'C', 'SW',
                     'SL', 'SR', 'SBL', 'SBR', 'SB']
                index = subcommands.index(subcmd)
                maxIndex = len(subcommands)
            elif key in ['Z1', 'Z2']:
                if value in ['ON', 'OFF']:
                    index = 2
                elif value[0] in '0123456789':
                    index = 1
                else:
                    index = 0
                maxIndex = 3
                subcmd = str(index)
            elif key == 'TM':
                if value in ['AM', 'FM']:
                    index = 0
                else:
                    index = 1
                maxIndex = 2
                subcmd = str(index)
        return key, subcmd, index, maxIndex, value

    def updateStatus(self, data):
        """update self.current with data received from Denon"""
        assert data[2] != '?'
        key, subcmd, index, maxIndex, value = self.parse(data)
        oldValue = self.current.get(key, None)
        if oldValue is not None and index is not None:
            oldValue = oldValue[index]
        if value != oldValue:
            if 'c' in OPTIONS.debug:
                LOGGER.debug('Denon: %s%s: %s --> %s' % (key, subcmd or '', oldValue, value))
        if index is None:
            self.current[key] = value
        else:
            if key not in self.current:
                self.current[key] = [None] * maxIndex
            self.current[key][index] = value

    def getResponses(self, expect=None):
        """get all pending responses or events.
        If expect (the expected response/event) is given,
        return its last value received within this call or None
        Since some commands take more time until they send
        events, the main loop of halirc also calls us for polling
        """
        result = None
        while True:
            data = self.readline('\r')
            if not data:
                break
            self.updateStatus(data)
            key, _, _, _, value = self.parse(data)
            if expect and key == self.parse(expect)[0]:
                result = value
                break # more responses will be read later
        return result

    def maybeDelay(self, cmd):
        """do we need to wait before sending this command?"""
        if not self.lastSentCmd:
            return
        cmd1 = self.lastSentCmd[:2]
        cmd2 = cmd[:2]
        delay = 0
        for key in (cmd1 + cmd2, cmd1 + '..', '..' + cmd2):
            if key in self.delays and self.delays[key] > delay:
                delay = self.delays[key]
        if delay:
            stillWaiting = delay - elapsedSince(self.lastSentTime)
            if stillWaiting > 0:
                if 's' in OPTIONS.debug:
                    LOGGER.debug('sleeping %s/%s between %s and %s' % ( \
                        stillWaiting, delay, self.lastSentCmd, cmd))
                time.sleep(stillWaiting)

    def send(self, cmd):
        """send cmd to Denon and return the answers if there are any
        some commands will return an answer as different command or no answer
        """
        key, _, _, _, _ = self.parse(cmd)
        self.maybeDelay(cmd)
        if key != 'PW' and not self.isPoweredOn():
            return ''
        self.communicate(cmd + '\r')
        if cmd[2] != '?':
            self.lastSentCmd = cmd
            self.lastSentTime = datetime.datetime.now()
            if key == 'TM':
                # the receiver does not confirm this
                self.updateStatus(cmd)
                return cmd
            elif key == 'SV':
                # the receiver does not confirm this
                if cmd != 'SVSOURCE':
                    self.updateStatus(cmd)
                return cmd
        return self.getResponses(cmd)

    def getAnswer(self, cmd):
        """ask Denon unless we already know the current value"""
        command = self.parse(cmd)[0]
        while not command in self.current:
            self.send(command + '?')
        return self.current[command]

    def sendIfNot(self, cmd):
        """if Denon is not on the wanted value, set it to it"""
        _, _, _, _, value = self.parse(cmd)
        if self.getAnswer(cmd) != value:
            self.send(cmd)

    def isPoweredOn(self):
        """is Denon powered on?"""
        return self.getAnswer('PW') == 'ON'

    def volume(self, newValue):
        """change volume up or down"""
        if self.isPoweredOn():
            if self.mutedVolume:
                self.mute()
            else:
                self.send('MV%s' % newValue)

    def mute(self):
        """toggle between mute/unmuted"""
        if self.isPoweredOn():
            if self.mutedVolume:
                newMV = self.mutedVolume
                self.mutedVolume = None
            else:
                while not 'MV' in self.current:
                    self.send('MV?')
                self.mutedVolume = self.current['MV']
                newMV = '20'
            self.send('MV%s' % newMV)

    def queryStatus(self, full=False):
        """query Denon status. If full, try to query even those
        parameters we do not know about"""
        if full:
            letters1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
            letters2 = letters1 + '1234567890'
            commands = []
            for letter1 in letters1:
                for letter2 in letters2:
                    commands.append(letter1 + letter2)
        else:
            # only query commands that might actually exist.
            # if full query finds more, please add them here
            commands = ['PS', 'ZM', 'PW', 'TP', 'MU', 'SI',
                'MV', 'MS', 'TF', 'CV', 'Z1', 'Z2', 'TM', 'SR']
        for command in commands:
            self.send('%s?' % command)
        for _ in range(0, 10):
            self.getResponses()
        if 'r' in OPTIONS.debug:
            LOGGER.debug('current status:%s ' % self.current)


class LGTV(SerialDevice):

    """Interface to probably most LG flatscreens"""
    def __init__(self, device='/dev/LGPlasma'):
        SerialDevice.__init__(self, device)
        self.commands = {
            'poweron':'ka 00 01',
            'poweroff': 'ka 00 00',
            'muteon': 'ke 00 00',
            'muteoff': 'ke 00 01',
            'osdon': 'kl 00 01',
            'osdoff': 'kl 00 00',
            'aspect43': 'kc 00 01',
            'aspect169': 'kc 00 02',
            'aspectzoom': 'kc 00 04',
            'aspectoriginal': 'kc 00 06',
            'aspect149': 'kc 00 07',
            'aspectscan': 'kc 00 09',
            'aspectfullwidth': 'kc 00 0B',
            'inputdtv': 'xb 00 00',
            'inputanalog': 'xb 00 10',
            'inputav': 'xb 00 20',
            'inputcomponent': 'xb 00 40',
            'inputhdmi1': 'xb 00 70',
            'inputhdmi2': 'xb 00 71',
            'mutescreenoff': 'kd 00 00',
            'mutescreenon': 'kd 00 01',
            'mutevideoon': 'kd 00 10'
        }
        for zoom in range(1, 17):
            self.commands['aspectcinema%d' % zoom] = 'kc 00 %02X' % (zoom + 15)

        for volume in range(0, 64):
            self.commands['volume%d' % volume] = 'kf 00 %02X' % volume
        self.videoMuted = None
        self.tvTimeout = 30

    def setEvent(self, event):
        """event is the next event to be processed or None if there
        was no event while timeout"""
        if not event:
            if self.tvTimeout-0.5 < elapsedSince(self.videoMuted) < self.tvTimeout+0.5:
                self.standby()
                self.close() # manual close because standby starts close timer again
        SerialDevice.setEvent(self, event)

    def init(self):
        """init the LGTV for VDR usage"""
        self.sendIfNot('01', 'poweron')
        self.sendIfNot('00', 'muteon')
        self.sendIfNot('00', 'volume0')
        self.sendIfNot('09', 'aspectscan')
        self.sendIfNot('00', 'mutescreenoff')

    def sendIfNot(self, wantedStatus, cmd):
        """if wantedStatus for cmd is not set in LGTV, set it"""
        status = self.getAnswer(cmd)
        if status != wantedStatus:
            if 's' in OPTIONS.debug:
                LOGGER.debug(
                  'status is %s but we want %s' % (status, wantedStatus))
            return self.send(cmd)

    def parse(self, cmd):
        """translate the human readable commands into LG command sequences"""
        if not cmd in self.commands:
            LOGGER.critical('LGTV: unknown argument %s' % cmd)
            sys.exit(2)
        return self.commands[cmd]

    def getAnswer(self, cmd):
        """ask the LGTV for a value"""
        command = self.parse(cmd)
        command = command[:6] + 'ff'
        for _ in range(0, 5):
            answer = self.communicate(command + '\r', True, eol='x')
            match = re.match(r'.*OK(.*)$', answer)
            if match:
                break
        if 'r' in OPTIONS.debug:
            LOGGER.debug('LG.getAnswer:%s ' % answer)
        if match:
            return match.groups()[0]

    def send(self, cmd):
        """send cmd to LGTV and return the answer"""
        command = self.parse(cmd)
        answer = self.communicate(command + '\r', True, eol='x')
        if not re.match(r'.*OK', answer):
            msg = '%s %s: ERROR %s' % (cmd, command, answer)
            LOGGER.error(msg)
        return answer

    def isPoweredOn(self):
        """is the LGTV on?"""
        return self.getAnswer('poweron') != '00'

    def standby(self):
        """power off the LGTV"""
        if self.isPoweredOn():
            self.send('poweroff')

    def mutevideo(self, muteButton):
        """except for muteButton, all remote buttons make video visible again"""
        if self.event.button == muteButton:
            self.videoMuted = datetime.datetime.now()
            self.send('mutevideoon')
        else:
            if self.getAnswer('mutevideoon') != '00':
                LOGGER.debug('unmuting')
                self.videoMuted = None
                self.init()

class Event(object):
    """keeps attributes for events from lirc"""
    def __init__(self, line=None, name=None, remote=None, button=None, repeat='00'):
        if line:
            if 'i' in OPTIONS.debug:
                LOGGER.debug('event:%s ' % line)
            self.code, self.repeat, self.button, self.remote = \
                line.strip().split(' ')
            self.name = ''
        else:
            self.code = None
            self.name = name
            self.remote = remote
            self.button = button
            self.repeat = repeat

    def __str__(self):
        return '%s %s %s' % (
           (self.name or 'anon'),
           (self.remote or 'all remotes'),
           (self.button or 'all buttons'))

    def __eq__(self, other):
        """compares remote, button, repeat. None is a wildcard."""
        if self.remote and other.remote and self.remote != other.remote:
            return False
        if self.button and other.button and self.button != other.button:
            return False
        if self.repeat and other.repeat and self.repeat != other.repeat:
            return False
        return True

def elapsedSince(since):
    """return the seconds elapsed since 'since'"""
    if since is not None:
        x = datetime.datetime.now() - since
        return float(x.microseconds + (x.seconds + x.days * 24 * 3600) * 10**6) / 10**6

class Irw(object):
    """get lirc events from the lirc socket, just like irw does"""
    LF = '\n'
    def __init__(self, name=None):
        if not name:
            name = '/var/run/lirc/lircd'
        self.name = name
        self.input = socket.socket( socket.AF_UNIX, socket.SOCK_STREAM)
        self.input.connect(name)
        self.input.settimeout(1)
        self.buf = ''

    def read(self):
        """returns a complete line from the lirc socket
        or None if timeout is reached"""
        if not self.LF in self.buf:
            try:
                self.buf += self.input.recv(100)
            except socket.timeout:
                pass
        if self.LF in self.buf:
            lines = self.buf.split(self.LF)
            self.buf = self.LF.join(lines[1:])
            return Event(lines[0])

def parseOptions():
    """should switch to argparse when debian stable has python 2.7"""
    parser = OptionParser()
    parser.add_option('-d', '--debug', dest='debug',
        help="""DEBUG:
a sequence of characters: 's' shows data sent to appliances.
'r' shows data read from appliances.
'i' shows data received from remote controls.
'c' shows changes in the appliance status.
'f' shows filtering info
             """, default='', metavar='DEBUG')
    parser.add_option('-b', '--background', dest='background',
        action="store_true", default=False,
        help="run in background. Logging goes to the syslogs.")
    return parser.parse_args()

def initLogger():
    """logging goes to stderr when running in foregrund, else
    to syslog"""
    logger = logging.getLogger('halirc')
    if OPTIONS.background:
        handler = logging.handlers.SysLogHandler('/dev/log')
    else:
        handler = logging.StreamHandler()
    logger.addHandler(handler)
    logger.setLevel(logging.DEBUG)
    if OPTIONS.background:
        # if we generate a ton of same messages, give syslog a change
        # to reduce log file output by always writing exactly the same msg
        formatter = logging.Formatter("%(name)s: %(levelname)s %(message)s")
    else:
        formatter = logging.Formatter("%(relativeCreated)d %(name)s: %(levelname)s %(message)s")
    handler.setFormatter(formatter)
    return logger

class Timer(object):
    """hold attributes needed for a timer"""
    # pylint: disable=R0913
    def __init__(self, action, name, args,
            minute=None, hour=None, day=None, month=None, weekday=None):
        self.action = action
        self.name = name
        self.args = args
        self.minute = minute
        self.hour = hour
        self.day = day
        self.month = month
        self.weekday = weekday
        self.lastDone = None

    def trigger(self):
        """if this timer should be executed now, do so"""
        now = datetime.datetime.now()
        if not self.lastDone or elapsedSince(self.lastDone) > 65:
            for tValue, nValue in (
                  (self.minute, now.minute),
                  (self.hour, now.hour),
                  (self.day, now.day),
                  (self.month, now.month),
                  (self.weekday, now.weekday())):
                if tValue is not None:
                    if isinstance(tValue, list):
                        if nValue not in tValue:
                            return
                    else:
                        if tValue != nValue:
                            return
            self.lastDone = now
            if self.args:
                if isinstance(self.args, list):
                    self.action(*self.args) # pylint: disable=W0142
                else:
                    self.action(self.args)
            else:
                self.action()

class Worker(object):
    """executes events if they match filters"""
    def __init__(self):
        self.filters = []
        self.events = []
        self.timers = []

    def addFilter(self, action, name=None, args=None, remote=None, button=None, repeat='00'):
        """None works as wildcard for remote, button, repeat.
        remote and button must always match literally.
        if more than one filters match, they are executed in their
        defined order. If a filter sets stopFiltering to True, the following filters
        will be ignored.
        args can be a single value or a list of arguments"""

        self.filters.append((Event(name=name, remote=remote, button=button, repeat=repeat),
             action, args))

    # pylint: disable=R0913
    def addTimer(self, action, args=None, name=None, minute=None, hour=None,
           day=None, month=None, weekday=None):
        """action is a method to be called with args
        when is a python datetime object"""
        self.timers.append(Timer(action, name, args, minute, hour, day, month, weekday))

    def execute(self, event):
        """for now, return True if any filter matched"""
        for timer in self.timers:
            timer.trigger()
        if event:
            foundFilter = False
            for fltr, action, args in self.filters:
                if fltr == event:
                    foundFilter = True
                    if 'f' in OPTIONS.debug:
                        LOGGER.debug('executing filter %s' % str(fltr))
                    if args:
                        if isinstance(args, list):
                            stopFiltering = action(*args) # pylint: disable=W0142
                        else:
                            stopFiltering = action(args)
                    else:
                        stopFiltering = action()
                    if stopFiltering is True:
                        break
            return foundFilter

class MorningAction(object):
    """very custom..."""
    def __init__(self, worker, vdr, denon, lgtv):
        self.vdr = vdr
        self.denon = denon
        self.lgtv = lgtv
        self.prevChannel = None
        self.silencer = '/home/wr/ausschlafen'
        workdays = [0, 1, 2, 3, 4, 5, 6]
        worker.addTimer(self.start, hour=3, minute=58, weekday=workdays)
        worker.addTimer(self.changeVolume, hour=4, minute=21, weekday=workdays)
        worker.addTimer(self.end, hour=4, minute=40, weekday=workdays)

    def wanted(self):
        """do we actually want to be triggered?"""
        if os.path.exists(self.silencer):
            return False
        return True

    def start(self):
        """start channel 93 loudly"""
        LOGGER.debug('morning.start')
        if self.wanted():
            self.denon.init()
            self.denon.sendIfNot('SIDBS/SAT')
            self.denon.sendIfNot('MV57')
            self.prevChannel = self.vdr.getChannel()
            if self.prevChannel != 'NDR 90,3':
                self.vdr.gotoChannel('NDR 90,3')
            else:
                self.prevChannel = None
            self.lgtv.standby()

    def changeVolume(self):
        """kitchen time"""
        LOGGER.debug('morning.changeVolume')
        if self.wanted():
            self.denon.send('MV42')

    def end(self):
        """off to train"""
        LOGGER.debug('morning.end')
        if self.wanted():
            self.denon.standby()
            if self.prevChannel:
                self.vdr.gotoChannel(self.prevChannel)
            self.lgtv.standby()
        elif os.path.exists(self.silencer):
            os.remove(self.silencer)

def main():
    """define main, avoid to pollute global namespace"""
    # pylint: disable=W0603
    global OPTIONS
    OPTIONS, _ = parseOptions()
    global LOGGER
    LOGGER = initLogger()

    irw = Irw()
    denon = Denon()
    lgPlasma = LGTV()
    vdr = VDRServer()
    appliances = [denon, lgPlasma, vdr]

    worker = Worker()

    # use buttons of an unused remote for controlling
    # the Denon because the IR receiver of the Denon
    # is too far away
    worker.addFilter(denon.volume, args='UP', remote='AcerP1165', button='Up', repeat=None)
    worker.addFilter(denon.volume, args='DOWN', remote='AcerP1165', button='Down', repeat=None)
    worker.addFilter(denon.mute, remote='AcerP1165', button='PgUp')
    worker.addFilter(denon.queryStatus, remote='AcerP1165', button='PgDown')
    worker.addFilter(denon.send, args='SIDBS/SAT', remote='AcerP1165', button='0')
    worker.addFilter(denon.send, args='SICD', remote='AcerP1165', button='1')
    worker.addFilter(denon.send, args='SITUNER', remote='AcerP1165', button='2')
    worker.addFilter(denon.send, args='SIDVD', remote='AcerP1165', button='3')
    worker.addFilter(denon.send, args='SIVDP', remote='AcerP1165', button='4')
    worker.addFilter(denon.send, args='SIVCR-1', remote='AcerP1165', button='5')
    worker.addFilter(denon.send, args='SIVCR-2', remote='AcerP1165', button='6')
    worker.addFilter(denon.send, args='SIV.AUX', remote='AcerP1165', button='7')
    worker.addFilter(denon.send, args='SICDR.TAPE', remote='AcerP1165', button='8')
    worker.addFilter(denon.send, args='SITV', remote='AcerP1165', button='9')
    worker.addFilter(denon.send, args='PWON', remote='AcerP1165', button='Left')
    worker.addFilter(denon.send, args='PWSTANDBY', remote='AcerP1165', button='Right')
    worker.addFilter(denon.send, args='TMAM', remote='AcerP1165', button='Freeze')
    worker.addFilter(denon.send, args='TMFM', remote='AcerP1165', button='Hide')
    worker.addFilter(os.system, args='dose_ein 3', button='Zoom')
    worker.addFilter(os.system, args='dose_aus 3', button='Resync')
    worker.addFilter(lgPlasma.mutevideo, args='Power2', remote='Hauppauge6400')
    worker.addFilter(lgPlasma.init, remote='Receiver12V', button='Power')
    worker.addFilter(lgPlasma.send, args='poweroff', remote='Receiver12V', button='0')
    worker.addFilter(lgPlasma.send, args='inputdtv', remote='Receiver12V', button='1')
    worker.addFilter(lgPlasma.send, args='inputhdmi1', remote='Receiver12V', button='2')
    worker.addFilter(lgPlasma.send, args='inputhdmi2', remote='Receiver12V', button='3')
    worker.addFilter(lgPlasma.send, args='inputcomponent', remote='Receiver12V', button='4')
    worker.addFilter(lgPlasma.send, args='inputanalog', remote='Receiver12V', button='5')
    worker.addFilter(vdr.switchVt, args='desktop', remote='Receiver12V', button='6')
    worker.addFilter(vdr.switchVt, args='video', remote='Receiver12V', button='7')

    morning = MorningAction(worker, vdr, denon, lgPlasma) # pylint: disable=W0612

    while True:
        event = irw.read()
        for appliance in appliances:
            appliance.setEvent(event)
        try:
            worker.execute(event)
        except Exception as exception: # pylint: disable=W0703
            LOGGER.error('%s: %s' % (event, exception), exc_info=True)

if __name__ == "__main__":
    main()
